#summary Persistent Object Storage (POS)
#labels Phase-Design

= Persistent Object Storage =

You create a new object and assign it to the storage (POS):

{{{
class Car extends FaZend_Pos_Abstract
{
    public function init()
    {
        $this->color = 'white';
        $this->model = false;
    }
    public function isGermanCar()
    {
        if ($this->model == 'bmw') {
            return true;
        }
        return false;
    }
}

FaZend_Pos_Properties::root()->bmw328 = new Car();
}}}

You can create a simple object as well:

{{{
$root = FaZend_Pos_Properties::root();
$root->cars = array();
$bmw = new Car();
$root->cars[] = $bmw;
$bmw->color = 'black';
$bwm->model = 'bmw';
}}}

Later, in another part of the application:

{{{
$bmw = current(FaZend_Pos_Properties::root()->cars);
echo $bmw->isGermanCar(); // returns TRUE
echo FaZend_Pos_Properties::root()->bmw328i->color; // returns 'white'
}}}

You can delete an object, or wipe it out (delete forever):

{{{
$car = FaZend_Pos_Properties::root()->bmw328i;
$car->ps()->delete(); // still in storage, but marked as deleted
$car->ps()->wipe(); // wipe it out, no more information in storage about it
}}}

Objects can include objects, and `FaZend_Pos` will understand such links. Objects won't be copied, but symbolic links will be created.

= Version Control =

Changes are under control, like in Subversion repository:

{{{
$car = FaZend_Pos_Properties::root()->bmw328i;
$ps = $car->ps(); // FaZend_Pos_Properties - system properties of the object
$ps->editor; // FaZend_User with the editor of latest changes
$ps->version; // FaZend_Pos_Version of the latest version
$ps->updated; // time when the object was updated last time
$ps->id; // int - unique id of the object in storage
$ps->type; // full name of the class for this object
$ps->parent; // parent object or NULL if it's root already
}}}

You can play with versions:

{{{
$car = FaZend_Pos_Properties::root()->bmw328i;
$version = $car->ps()->version;
$car->ps()->workWithVersion($version - 1); // now the object has data from previous version
$car->ps()->setTimeBoundary(time() - 60*60); // ignore any changes made during the last hour
$car->ps()->touch(); // increases the version of the object, no other changes
$car->ps()->rollBack($version - 1); // roll back all changes to previous version
$car->ps()->getVersions(10); // returns an array of 10 latest version
$car->ps()->getAge(); // returns object age in storage, in seconds
}}}

= Access Control =

You can setup an access control object, which will be responsible for user access rights management for any particular object. Before any operation `FaZend_POS` will ask this `ACL` whether this operation is permitted or not, giving the object name to it:

{{{
FaZend_Pos_Properties::root()->ps()->setAcl(new Zend_Acl());
}}}

= Branching =

You (some user) can create a branch of any object and then work with this branch (at most one branch per user):

{{{
$car = FaZend_Pos_Properties::root()->bmw328i;
$car->ps()->branch(); // create a new branch for current user (overwrite the existing one, if any)
$car->ps()->revert(); // get back to "trunk"
$car->ps()->commit($user); // commit user's changes to trunk (overwriting existing version) 
$car->ps()->respectBranch(true); // during this session we should work with the branch (default option) or "trunk"
$car->ps()->respectBranch($user); // during this session we should work with this branch (by this user)
}}}

When the object becomes baselined all branches becomes unavailable.

= Other ideas =

 * Maybe `xpath()` search on the full storage is a good option.			
 * Automated cleaning of very old version
 * `exportXML()`, `importXML()`
 * `diff()`